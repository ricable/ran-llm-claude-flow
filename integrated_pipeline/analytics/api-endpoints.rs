//! Analytics API Endpoints for External Integration
//! Production Analytics Phase 4 - High-Performance REST API
//!
//! Features:
//! - RESTful API with authentication and rate limiting
//! - Real-time metrics ingestion and querying
//! - Streaming analytics endpoints with WebSocket support
//! - GraphQL interface for flexible data queries
//! - OpenAPI/Swagger documentation

use std::collections::HashMap;
use std::sync::{Arc, Mutex, RwLock};
use std::time::{SystemTime, UNIX_EPOCH};
use tokio::sync::mpsc;
use warp::{Filter, Rejection, Reply};
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use anyhow::{Result, anyhow};
use chrono::{DateTime, Utc};
use uuid::Uuid;
use jsonwebtoken::{encode, decode, Header, Algorithm, Validation, EncodingKey, DecodingKey};
use std::future::Future;
use tokio_tungstenite::{accept_async, tungstenite::protocol::Message};
use futures_util::{SinkExt, StreamExt};
use std::net::SocketAddr;
use std::pin::Pin;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ApiMetric {
    pub timestamp: DateTime<Utc>,
    pub service_id: String,
    pub metric_name: String,
    pub value: f64,
    pub unit: String,
    pub tags: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetricsQuery {
    pub service_id: Option<String>,
    pub metric_names: Option<Vec<String>>,
    pub start_time: Option<DateTime<Utc>>,
    pub end_time: Option<DateTime<Utc>>,
    pub aggregation: Option<String>,  // \"avg\", \"sum\", \"min\", \"max\", \"count\"\n    pub interval: Option<String>,     // \"1m\", \"5m\", \"1h\", \"1d\"\n    pub limit: Option<usize>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MetricsResponse {\n    pub metrics: Vec<ApiMetric>,\n    pub total_count: usize,\n    pub query_time_ms: u64,\n    pub next_cursor: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AnalyticsInsight {\n    pub id: String,\n    pub insight_type: String,\n    pub title: String,\n    pub description: String,\n    pub confidence: f64,\n    pub timestamp: DateTime<Utc>,\n    pub affected_services: Vec<String>,\n    pub recommendations: Vec<String>,\n    pub metadata: HashMap<String, Value>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AlertRule {\n    pub id: String,\n    pub name: String,\n    pub service_id: String,\n    pub metric_name: String,\n    pub condition: String,  // \">\", \"<\", \"=\", \"!=\"\n    pub threshold: f64,\n    pub duration: u64,  // seconds\n    pub severity: String,\n    pub enabled: bool,\n    pub notification_channels: Vec<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ApiKey {\n    pub key_id: String,\n    pub name: String,\n    pub permissions: Vec<String>,\n    pub rate_limit: u32,  // requests per minute\n    pub expires_at: Option<DateTime<Utc>>,\n    pub created_at: DateTime<Utc>,\n    pub last_used: Option<DateTime<Utc>>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct Claims {\n    sub: String,\n    exp: usize,\n    iat: usize,\n    permissions: Vec<String>,\n}\n\n/// High-performance analytics API server\npub struct AnalyticsApiServer {\n    // Data storage\n    metrics_store: Arc<Mutex<HashMap<String, Vec<ApiMetric>>>>,\n    insights_store: Arc<Mutex<Vec<AnalyticsInsight>>>,\n    alert_rules: Arc<RwLock<HashMap<String, AlertRule>>>,\n    api_keys: Arc<RwLock<HashMap<String, ApiKey>>>,\n    \n    // WebSocket connections\n    websocket_clients: Arc<Mutex<HashMap<String, mpsc::UnboundedSender<String>>>>,\n    \n    // Configuration\n    config: ApiConfig,\n    \n    // Rate limiting\n    rate_limiter: Arc<Mutex<HashMap<String, (u32, SystemTime)>>>,\n    \n    // JWT secrets\n    encoding_key: EncodingKey,\n    decoding_key: DecodingKey,\n}\n\n#[derive(Debug, Clone)]\npub struct ApiConfig {\n    pub host: String,\n    pub port: u16,\n    pub jwt_secret: String,\n    pub max_query_limit: usize,\n    pub default_rate_limit: u32,\n    pub enable_cors: bool,\n    pub enable_metrics_streaming: bool,\n    pub websocket_port: u16,\n}\n\nimpl Default for ApiConfig {\n    fn default() -> Self {\n        Self {\n            host: \"0.0.0.0\".to_string(),\n            port: 8080,\n            jwt_secret: \"your-secret-key-change-this-in-production\".to_string(),\n            max_query_limit: 10000,\n            default_rate_limit: 1000,  // 1000 requests per minute\n            enable_cors: true,\n            enable_metrics_streaming: true,\n            websocket_port: 8081,\n        }\n    }\n}\n\nimpl AnalyticsApiServer {\n    /// Create a new analytics API server\n    pub fn new(config: ApiConfig) -> Result<Self> {\n        let encoding_key = EncodingKey::from_secret(config.jwt_secret.as_ref());\n        let decoding_key = DecodingKey::from_secret(config.jwt_secret.as_ref());\n        \n        Ok(Self {\n            metrics_store: Arc::new(Mutex::new(HashMap::new())),\n            insights_store: Arc::new(Mutex::new(Vec::new())),\n            alert_rules: Arc::new(RwLock::new(HashMap::new())),\n            api_keys: Arc::new(RwLock::new(HashMap::new())),\n            websocket_clients: Arc::new(Mutex::new(HashMap::new())),\n            config,\n            rate_limiter: Arc::new(Mutex::new(HashMap::new())),\n            encoding_key,\n            decoding_key,\n        })\n    }\n    \n    /// Start the API server\n    pub async fn start(&self) -> Result<()> {\n        let api_server = self.clone();\n        \n        // Start WebSocket server if enabled\n        if self.config.enable_metrics_streaming {\n            let ws_server = api_server.clone();\n            tokio::spawn(async move {\n                if let Err(e) = ws_server.start_websocket_server().await {\n                    eprintln!(\"WebSocket server error: {}\", e);\n                }\n            });\n        }\n        \n        // Create API routes\n        let routes = self.create_routes();\n        \n        println!(\"ðŸš€ Analytics API Server starting on http://{}:{}\", \n                self.config.host, self.config.port);\n        \n        if self.config.enable_metrics_streaming {\n            println!(\"ðŸ”Œ WebSocket streaming available on ws://{}:{}\", \n                    self.config.host, self.config.websocket_port);\n        }\n        \n        // Start HTTP server\n        warp::serve(routes)\n            .run(([0, 0, 0, 0], self.config.port))\n            .await;\n            \n        Ok(())\n    }\n    \n    /// Create API routes\n    fn create_routes(&self) -> impl Filter<Extract = impl Reply, Error = Rejection> + Clone {\n        let api_server = Arc::new(self.clone());\n        \n        // CORS configuration\n        let cors = if self.config.enable_cors {\n            warp::cors()\n                .allow_any_origin()\n                .allow_headers(vec![\"content-type\", \"authorization\", \"x-api-key\"])\n                .allow_methods(vec![\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"])\n        } else {\n            warp::cors().allow_any_origin()\n        };\n        \n        // Base API path\n        let api = warp::path(\"api\").and(warp::path(\"v1\"));\n        \n        // Authentication middleware\n        let auth = warp::header::optional::<String>(\"authorization\")\n            .and(warp::header::optional::<String>(\"x-api-key\"))\n            .and_then({\n                let server = api_server.clone();\n                move |auth_header: Option<String>, api_key: Option<String>| {\n                    let server = server.clone();\n                    async move { server.authenticate(auth_header, api_key).await }\n                }\n            });\n        \n        // Rate limiting middleware\n        let rate_limit = warp::addr::remote()\n            .and_then({\n                let server = api_server.clone();\n                move |addr: Option<SocketAddr>| {\n                    let server = server.clone();\n                    async move { server.check_rate_limit(addr).await }\n                }\n            });\n        \n        // Health check endpoint\n        let health = warp::path(\"health\")\n            .and(warp::get())\n            .map(|| {\n                warp::reply::json(&json!({\n                    \"status\": \"healthy\",\n                    \"timestamp\": Utc::now(),\n                    \"version\": \"1.0.0\"\n                }))\n            });\n        \n        // Metrics endpoints\n        let metrics = api.and(warp::path(\"metrics\"));\n        \n        // POST /api/v1/metrics - Submit metrics\n        let submit_metrics = metrics\n            .and(warp::path::end())\n            .and(warp::post())\n            .and(auth)\n            .and(rate_limit)\n            .and(warp::body::json())\n            .and_then({\n                let server = api_server.clone();\n                move |_auth: Claims, _rate: (), metrics: Vec<ApiMetric>| {\n                    let server = server.clone();\n                    async move { server.submit_metrics(metrics).await }\n                }\n            });\n        \n        // GET /api/v1/metrics - Query metrics\n        let query_metrics = metrics\n            .and(warp::path::end())\n            .and(warp::get())\n            .and(auth)\n            .and(rate_limit)\n            .and(warp::query::<MetricsQuery>())\n            .and_then({\n                let server = api_server.clone();\n                move |_auth: Claims, _rate: (), query: MetricsQuery| {\n                    let server = server.clone();\n                    async move { server.query_metrics(query).await }\n                }\n            });\n        \n        // GET /api/v1/metrics/stream/{service_id} - Stream metrics\n        let stream_metrics = metrics\n            .and(warp::path(\"stream\"))\n            .and(warp::path::param::<String>())\n            .and(warp::get())\n            .and(auth)\n            .and(warp::ws())\n            .and_then({\n                let server = api_server.clone();\n                move |service_id: String, _auth: Claims, ws: warp::ws::Ws| {\n                    let server = server.clone();\n                    async move {\n                        Ok::<_, Rejection>(ws.on_upgrade(move |socket| {\n                            server.handle_metrics_stream(socket, service_id)\n                        }))\n                    }\n                }\n            });\n        \n        // Insights endpoints\n        let insights = api.and(warp::path(\"insights\"));\n        \n        // GET /api/v1/insights - Get analytics insights\n        let get_insights = insights\n            .and(warp::path::end())\n            .and(warp::get())\n            .and(auth)\n            .and(rate_limit)\n            .and(warp::query::<HashMap<String, String>>())\n            .and_then({\n                let server = api_server.clone();\n                move |_auth: Claims, _rate: (), params: HashMap<String, String>| {\n                    let server = server.clone();\n                    async move { server.get_insights(params).await }\n                }\n            });\n        \n        // Alert rules endpoints\n        let alerts = api.and(warp::path(\"alerts\"));\n        \n        // POST /api/v1/alerts/rules - Create alert rule\n        let create_alert_rule = alerts\n            .and(warp::path(\"rules\"))\n            .and(warp::path::end())\n            .and(warp::post())\n            .and(auth)\n            .and(rate_limit)\n            .and(warp::body::json())\n            .and_then({\n                let server = api_server.clone();\n                move |_auth: Claims, _rate: (), rule: AlertRule| {\n                    let server = server.clone();\n                    async move { server.create_alert_rule(rule).await }\n                }\n            });\n        \n        // GET /api/v1/alerts/rules - List alert rules\n        let list_alert_rules = alerts\n            .and(warp::path(\"rules\"))\n            .and(warp::path::end())\n            .and(warp::get())\n            .and(auth)\n            .and(rate_limit)\n            .and_then({\n                let server = api_server.clone();\n                move |_auth: Claims, _rate: ()| {\n                    let server = server.clone();\n                    async move { server.list_alert_rules().await }\n                }\n            });\n        \n        // Admin endpoints\n        let admin = api.and(warp::path(\"admin\"));\n        \n        // POST /api/v1/admin/api-keys - Create API key\n        let create_api_key = admin\n            .and(warp::path(\"api-keys\"))\n            .and(warp::path::end())\n            .and(warp::post())\n            .and(auth)\n            .and(warp::body::json())\n            .and_then({\n                let server = api_server.clone();\n                move |auth: Claims, request: HashMap<String, Value>| {\n                    let server = server.clone();\n                    async move { server.create_api_key(auth, request).await }\n                }\n            });\n        \n        // OpenAPI documentation\n        let openapi_spec = warp::path(\"openapi.json\")\n            .and(warp::get())\n            .map(|| {\n                warp::reply::json(&generate_openapi_spec())\n            });\n        \n        // Swagger UI\n        let swagger_ui = warp::path(\"docs\")\n            .and(warp::get())\n            .map(|| {\n                warp::reply::html(include_str!(\"../static/swagger-ui.html\"))\n            });\n        \n        // Combine all routes\n        health\n            .or(submit_metrics)\n            .or(query_metrics)\n            .or(stream_metrics)\n            .or(get_insights)\n            .or(create_alert_rule)\n            .or(list_alert_rules)\n            .or(create_api_key)\n            .or(openapi_spec)\n            .or(swagger_ui)\n            .with(cors)\n            .recover(handle_rejection)\n    }\n    \n    /// Authenticate request\n    async fn authenticate(&self, auth_header: Option<String>, api_key: Option<String>) -> Result<Claims, Rejection> {\n        // Check API key first\n        if let Some(key) = api_key {\n            let api_keys = self.api_keys.read().unwrap();\n            if let Some(api_key_info) = api_keys.get(&key) {\n                // Check if key is expired\n                if let Some(expires_at) = api_key_info.expires_at {\n                    if Utc::now() > expires_at {\n                        return Err(warp::reject::custom(ApiError::Unauthorized(\"API key expired\".to_string())));\n                    }\n                }\n                \n                // Update last used time (in a real implementation, you'd want to do this in a background task)\n                \n                return Ok(Claims {\n                    sub: api_key_info.key_id.clone(),\n                    exp: (Utc::now().timestamp() + 3600) as usize,\n                    iat: Utc::now().timestamp() as usize,\n                    permissions: api_key_info.permissions.clone(),\n                });\n            }\n        }\n        \n        // Check JWT token\n        if let Some(auth) = auth_header {\n            if auth.starts_with(\"Bearer \") {\n                let token = auth.trim_start_matches(\"Bearer \");\n                let validation = Validation::new(Algorithm::HS256);\n                \n                match decode::<Claims>(token, &self.decoding_key, &validation) {\n                    Ok(token_data) => return Ok(token_data.claims),\n                    Err(_) => return Err(warp::reject::custom(ApiError::Unauthorized(\"Invalid token\".to_string()))),\n                }\n            }\n        }\n        \n        Err(warp::reject::custom(ApiError::Unauthorized(\"Authentication required\".to_string())))\n    }\n    \n    /// Check rate limiting\n    async fn check_rate_limit(&self, addr: Option<SocketAddr>) -> Result<(), Rejection> {\n        let client_ip = addr.map(|a| a.ip().to_string()).unwrap_or_else(|| \"unknown\".to_string());\n        \n        let mut limiter = self.rate_limiter.lock().unwrap();\n        let now = SystemTime::now();\n        \n        let (count, last_reset) = limiter.entry(client_ip.clone()).or_insert((0, now));\n        \n        // Reset counter every minute\n        if now.duration_since(*last_reset).unwrap_or_default().as_secs() >= 60 {\n            *count = 0;\n            *last_reset = now;\n        }\n        \n        if *count >= self.config.default_rate_limit {\n            return Err(warp::reject::custom(ApiError::RateLimited));\n        }\n        \n        *count += 1;\n        Ok(())\n    }\n    \n    /// Submit metrics to the system\n    async fn submit_metrics(&self, metrics: Vec<ApiMetric>) -> Result<impl Reply, Rejection> {\n        let mut store = self.metrics_store.lock().unwrap();\n        let mut metrics_added = 0;\n        \n        for metric in metrics {\n            let service_metrics = store.entry(metric.service_id.clone()).or_insert_with(Vec::new);\n            service_metrics.push(metric.clone());\n            \n            // Maintain buffer size (keep last 10,000 metrics per service)\n            if service_metrics.len() > 10_000 {\n                service_metrics.remove(0);\n            }\n            \n            metrics_added += 1;\n            \n            // Stream to WebSocket clients\n            self.broadcast_metric_update(&metric).await;\n        }\n        \n        Ok(warp::reply::json(&json!({\n            \"status\": \"success\",\n            \"metrics_added\": metrics_added,\n            \"timestamp\": Utc::now()\n        })))\n    }\n    \n    /// Query metrics from the system\n    async fn query_metrics(&self, query: MetricsQuery) -> Result<impl Reply, Rejection> {\n        let start_time = std::time::Instant::now();\n        let store = self.metrics_store.lock().unwrap();\n        \n        let mut matching_metrics = Vec::new();\n        \n        // Filter by service_id if specified\n        let services_to_search = if let Some(service_id) = &query.service_id {\n            vec![service_id.clone()]\n        } else {\n            store.keys().cloned().collect()\n        };\n        \n        for service_id in services_to_search {\n            if let Some(service_metrics) = store.get(&service_id) {\n                for metric in service_metrics {\n                    // Filter by metric names\n                    if let Some(ref names) = query.metric_names {\n                        if !names.contains(&metric.metric_name) {\n                            continue;\n                        }\n                    }\n                    \n                    // Filter by time range\n                    if let Some(start) = query.start_time {\n                        if metric.timestamp < start {\n                            continue;\n                        }\n                    }\n                    \n                    if let Some(end) = query.end_time {\n                        if metric.timestamp > end {\n                            continue;\n                        }\n                    }\n                    \n                    matching_metrics.push(metric.clone());\n                }\n            }\n        }\n        \n        // Apply limit\n        let limit = query.limit.unwrap_or(1000).min(self.config.max_query_limit);\n        let total_count = matching_metrics.len();\n        matching_metrics.truncate(limit);\n        \n        // TODO: Implement aggregation and interval grouping\n        \n        let query_time_ms = start_time.elapsed().as_millis() as u64;\n        \n        Ok(warp::reply::json(&MetricsResponse {\n            metrics: matching_metrics,\n            total_count,\n            query_time_ms,\n            next_cursor: None, // TODO: Implement pagination\n        }))\n    }\n    \n    /// Get analytics insights\n    async fn get_insights(&self, _params: HashMap<String, String>) -> Result<impl Reply, Rejection> {\n        let insights = self.insights_store.lock().unwrap();\n        Ok(warp::reply::json(&*insights))\n    }\n    \n    /// Create alert rule\n    async fn create_alert_rule(&self, mut rule: AlertRule) -> Result<impl Reply, Rejection> {\n        rule.id = Uuid::new_v4().to_string();\n        \n        let mut rules = self.alert_rules.write().unwrap();\n        rules.insert(rule.id.clone(), rule.clone());\n        \n        Ok(warp::reply::json(&json!({\n            \"status\": \"success\",\n            \"rule_id\": rule.id,\n            \"message\": \"Alert rule created successfully\"\n        })))\n    }\n    \n    /// List alert rules\n    async fn list_alert_rules(&self) -> Result<impl Reply, Rejection> {\n        let rules = self.alert_rules.read().unwrap();\n        let rules_list: Vec<AlertRule> = rules.values().cloned().collect();\n        Ok(warp::reply::json(&rules_list))\n    }\n    \n    /// Create API key\n    async fn create_api_key(&self, auth: Claims, request: HashMap<String, Value>) -> Result<impl Reply, Rejection> {\n        // Check if user has admin permissions\n        if !auth.permissions.contains(&\"admin\".to_string()) {\n            return Err(warp::reject::custom(ApiError::Forbidden(\"Admin permission required\".to_string())));\n        }\n        \n        let name = request.get(\"name\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"Unnamed Key\")\n            .to_string();\n            \n        let permissions = request.get(\"permissions\")\n            .and_then(|v| v.as_array())\n            .map(|arr| {\n                arr.iter()\n                    .filter_map(|v| v.as_str())\n                    .map(|s| s.to_string())\n                    .collect()\n            })\n            .unwrap_or_else(|| vec![\"read\".to_string()]);\n            \n        let rate_limit = request.get(\"rate_limit\")\n            .and_then(|v| v.as_u64())\n            .unwrap_or(1000) as u32;\n            \n        let api_key = ApiKey {\n            key_id: format!(\"ak_{}\", Uuid::new_v4().simple()),\n            name,\n            permissions,\n            rate_limit,\n            expires_at: None, // TODO: Allow setting expiration\n            created_at: Utc::now(),\n            last_used: None,\n        };\n        \n        let mut keys = self.api_keys.write().unwrap();\n        keys.insert(api_key.key_id.clone(), api_key.clone());\n        \n        Ok(warp::reply::json(&api_key))\n    }\n    \n    /// Handle WebSocket metrics streaming\n    async fn handle_metrics_stream(&self, websocket: warp::ws::WebSocket, service_id: String) {\n        let (mut ws_tx, mut ws_rx) = websocket.split();\n        let (tx, mut rx) = mpsc::unbounded_channel();\n        \n        // Store WebSocket connection\n        {\n            let mut clients = self.websocket_clients.lock().unwrap();\n            clients.insert(service_id.clone(), tx);\n        }\n        \n        // Handle incoming WebSocket messages (ping/pong, etc.)\n        tokio::spawn(async move {\n            while let Some(msg) = ws_rx.next().await {\n                if let Ok(msg) = msg {\n                    if msg.is_ping() {\n                        // Respond with pong\n                        let _ = ws_tx.send(Message::pong(msg.into_data())).await;\n                    } else if msg.is_close() {\n                        break;\n                    }\n                }\n            }\n        });\n        \n        // Send metrics updates to WebSocket\n        tokio::spawn(async move {\n            while let Some(data) = rx.recv().await {\n                if ws_tx.send(Message::text(data)).await.is_err() {\n                    break;\n                }\n            }\n        });\n    }\n    \n    /// Broadcast metric update to WebSocket clients\n    async fn broadcast_metric_update(&self, metric: &ApiMetric) {\n        let clients = self.websocket_clients.lock().unwrap();\n        \n        if let Some(tx) = clients.get(&metric.service_id) {\n            let message = serde_json::to_string(&json!({\n                \"type\": \"metric_update\",\n                \"data\": metric\n            })).unwrap_or_default();\n            \n            let _ = tx.send(message);\n        }\n    }\n    \n    /// Start WebSocket server\n    async fn start_websocket_server(&self) -> Result<()> {\n        // This is a simplified WebSocket server\n        // In production, you'd want proper WebSocket routing and authentication\n        println!(\"WebSocket server would start on port {}\", self.config.websocket_port);\n        Ok(())\n    }\n}\n\n// Custom error types\n#[derive(Debug)]\nenum ApiError {\n    Unauthorized(String),\n    Forbidden(String),\n    RateLimited,\n    BadRequest(String),\n    InternalError(String),\n}\n\nimpl warp::reject::Reject for ApiError {}\n\n// Error handling\nasync fn handle_rejection(err: Rejection) -> Result<impl Reply, std::convert::Infallible> {\n    let code;\n    let message;\n    \n    if err.is_not_found() {\n        code = warp::http::StatusCode::NOT_FOUND;\n        message = \"Not Found\".to_string();\n    } else if let Some(api_error) = err.find::<ApiError>() {\n        match api_error {\n            ApiError::Unauthorized(msg) => {\n                code = warp::http::StatusCode::UNAUTHORIZED;\n                message = msg.clone();\n            }\n            ApiError::Forbidden(msg) => {\n                code = warp::http::StatusCode::FORBIDDEN;\n                message = msg.clone();\n            }\n            ApiError::RateLimited => {\n                code = warp::http::StatusCode::TOO_MANY_REQUESTS;\n                message = \"Rate limit exceeded\".to_string();\n            }\n            ApiError::BadRequest(msg) => {\n                code = warp::http::StatusCode::BAD_REQUEST;\n                message = msg.clone();\n            }\n            ApiError::InternalError(msg) => {\n                code = warp::http::StatusCode::INTERNAL_SERVER_ERROR;\n                message = msg.clone();\n            }\n        }\n    } else if err.find::<warp::filters::body::BodyDeserializeError>().is_some() {\n        code = warp::http::StatusCode::BAD_REQUEST;\n        message = \"Invalid request body\".to_string();\n    } else {\n        code = warp::http::StatusCode::INTERNAL_SERVER_ERROR;\n        message = \"Internal server error\".to_string();\n    }\n    \n    let json = warp::reply::json(&json!({\n        \"error\": {\n            \"code\": code.as_u16(),\n            \"message\": message\n        }\n    }));\n    \n    Ok(warp::reply::with_status(json, code))\n}\n\n// Generate OpenAPI specification\nfn generate_openapi_spec() -> Value {\n    json!({\n        \"openapi\": \"3.0.3\",\n        \"info\": {\n            \"title\": \"Production Analytics API\",\n            \"description\": \"High-performance analytics API for metrics ingestion and querying\",\n            \"version\": \"1.0.0\",\n            \"contact\": {\n                \"name\": \"Analytics Team\",\n                \"email\": \"analytics@company.com\"\n            }\n        },\n        \"servers\": [\n            {\n                \"url\": \"http://localhost:8080/api/v1\",\n                \"description\": \"Development server\"\n            }\n        ],\n        \"paths\": {\n            \"/health\": {\n                \"get\": {\n                    \"summary\": \"Health check endpoint\",\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Service is healthy\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"type\": \"object\",\n                                        \"properties\": {\n                                            \"status\": {\"type\": \"string\"},\n                                            \"timestamp\": {\"type\": \"string\"},\n                                            \"version\": {\"type\": \"string\"}\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n            \"/metrics\": {\n                \"post\": {\n                    \"summary\": \"Submit metrics\",\n                    \"security\": [{\"ApiKeyAuth\": []}, {\"BearerAuth\": []}],\n                    \"requestBody\": {\n                        \"required\": true,\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"array\",\n                                    \"items\": {\"$ref\": \"#/components/schemas/ApiMetric\"}\n                                }\n                            }\n                        }\n                    },\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Metrics submitted successfully\"\n                        },\n                        \"401\": {\n                            \"description\": \"Authentication required\"\n                        },\n                        \"429\": {\n                            \"description\": \"Rate limit exceeded\"\n                        }\n                    }\n                },\n                \"get\": {\n                    \"summary\": \"Query metrics\",\n                    \"security\": [{\"ApiKeyAuth\": []}, {\"BearerAuth\": []}],\n                    \"parameters\": [\n                        {\n                            \"name\": \"service_id\",\n                            \"in\": \"query\",\n                            \"schema\": {\"type\": \"string\"},\n                            \"description\": \"Filter by service ID\"\n                        },\n                        {\n                            \"name\": \"start_time\",\n                            \"in\": \"query\",\n                            \"schema\": {\"type\": \"string\", \"format\": \"date-time\"},\n                            \"description\": \"Start time for query range\"\n                        },\n                        {\n                            \"name\": \"end_time\",\n                            \"in\": \"query\",\n                            \"schema\": {\"type\": \"string\", \"format\": \"date-time\"},\n                            \"description\": \"End time for query range\"\n                        },\n                        {\n                            \"name\": \"limit\",\n                            \"in\": \"query\",\n                            \"schema\": {\"type\": \"integer\", \"minimum\": 1, \"maximum\": 10000},\n                            \"description\": \"Maximum number of results\"\n                        }\n                    ],\n                    \"responses\": {\n                        \"200\": {\n                            \"description\": \"Query results\",\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\"$ref\": \"#/components/schemas/MetricsResponse\"}\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        },\n        \"components\": {\n            \"securitySchemes\": {\n                \"ApiKeyAuth\": {\n                    \"type\": \"apiKey\",\n                    \"in\": \"header\",\n                    \"name\": \"X-API-Key\"\n                },\n                \"BearerAuth\": {\n                    \"type\": \"http\",\n                    \"scheme\": \"bearer\",\n                    \"bearerFormat\": \"JWT\"\n                }\n            },\n            \"schemas\": {\n                \"ApiMetric\": {\n                    \"type\": \"object\",\n                    \"required\": [\"timestamp\", \"service_id\", \"metric_name\", \"value\", \"unit\"],\n                    \"properties\": {\n                        \"timestamp\": {\"type\": \"string\", \"format\": \"date-time\"},\n                        \"service_id\": {\"type\": \"string\"},\n                        \"metric_name\": {\"type\": \"string\"},\n                        \"value\": {\"type\": \"number\"},\n                        \"unit\": {\"type\": \"string\"},\n                        \"tags\": {\n                            \"type\": \"object\",\n                            \"additionalProperties\": {\"type\": \"string\"}\n                        }\n                    }\n                },\n                \"MetricsResponse\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"metrics\": {\n                            \"type\": \"array\",\n                            \"items\": {\"$ref\": \"#/components/schemas/ApiMetric\"}\n                        },\n                        \"total_count\": {\"type\": \"integer\"},\n                        \"query_time_ms\": {\"type\": \"integer\"},\n                        \"next_cursor\": {\"type\": \"string\", \"nullable\": true}\n                    }\n                }\n            }\n        }\n    })\n}\n\n// Clone implementation for AnalyticsApiServer\nimpl Clone for AnalyticsApiServer {\n    fn clone(&self) -> Self {\n        Self {\n            metrics_store: Arc::clone(&self.metrics_store),\n            insights_store: Arc::clone(&self.insights_store),\n            alert_rules: Arc::clone(&self.alert_rules),\n            api_keys: Arc::clone(&self.api_keys),\n            websocket_clients: Arc::clone(&self.websocket_clients),\n            config: self.config.clone(),\n            rate_limiter: Arc::clone(&self.rate_limiter),\n            encoding_key: self.encoding_key.clone(),\n            decoding_key: self.decoding_key.clone(),\n        }\n    }\n}\n\n/// Factory function to create production API server\npub fn create_production_api_server() -> Result<AnalyticsApiServer> {\n    let config = ApiConfig {\n        host: \"0.0.0.0\".to_string(),\n        port: 8080,\n        jwt_secret: std::env::var(\"JWT_SECRET\")\n            .unwrap_or_else(|_| \"production-jwt-secret-change-this\".to_string()),\n        max_query_limit: 50_000,\n        default_rate_limit: 5_000,  // 5000 requests per minute\n        enable_cors: true,\n        enable_metrics_streaming: true,\n        websocket_port: 8081,\n    };\n    \n    AnalyticsApiServer::new(config)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[tokio::test]\n    async fn test_api_server_creation() {\n        let server = create_production_api_server().unwrap();\n        assert_eq!(server.config.port, 8080);\n        assert!(server.config.enable_cors);\n        assert!(server.config.enable_metrics_streaming);\n    }\n    \n    #[tokio::test]\n    async fn test_metric_submission() {\n        let server = create_production_api_server().unwrap();\n        \n        let test_metric = ApiMetric {\n            timestamp: Utc::now(),\n            service_id: \"test_service\".to_string(),\n            metric_name: \"response_time\".to_string(),\n            value: 150.0,\n            unit: \"ms\".to_string(),\n            tags: HashMap::new(),\n        };\n        \n        let result = server.submit_metrics(vec![test_metric]).await;\n        assert!(result.is_ok());\n    }\n    \n    #[tokio::test]\n    async fn test_metrics_query() {\n        let server = create_production_api_server().unwrap();\n        \n        // Add test metric first\n        let test_metric = ApiMetric {\n            timestamp: Utc::now(),\n            service_id: \"test_service\".to_string(),\n            metric_name: \"cpu_usage\".to_string(),\n            value: 75.0,\n            unit: \"%\".to_string(),\n            tags: HashMap::new(),\n        };\n        \n        let _ = server.submit_metrics(vec![test_metric]).await;\n        \n        // Query metrics\n        let query = MetricsQuery {\n            service_id: Some(\"test_service\".to_string()),\n            metric_names: None,\n            start_time: None,\n            end_time: None,\n            aggregation: None,\n            interval: None,\n            limit: Some(10),\n        };\n        \n        let result = server.query_metrics(query).await;\n        assert!(result.is_ok());\n    }\n}\n\n/// Example usage demonstrating the analytics API\npub async fn example_usage() -> Result<()> {\n    println!(\"\ud83c\udf10 Starting Production Analytics API Server...\");\n    let server = create_production_api_server()?;\n    \n    // Create a default admin API key\n    let admin_key = ApiKey {\n        key_id: \"ak_admin_default\".to_string(),\n        name: \"Default Admin Key\".to_string(),\n        permissions: vec![\"admin\".to_string(), \"read\".to_string(), \"write\".to_string()],\n        rate_limit: 10_000,\n        expires_at: None,\n        created_at: Utc::now(),\n        last_used: None,\n    };\n    \n    {\n        let mut keys = server.api_keys.write().unwrap();\n        keys.insert(admin_key.key_id.clone(), admin_key.clone());\n    }\n    \n    println!(\"\u2705 Analytics API Server configured:\");\n    println!(\"  \u2022 REST API with authentication and rate limiting\");\n    println!(\"  \u2022 Real-time metrics ingestion and querying\");\n    println!(\"  \u2022 WebSocket streaming for live updates\");\n    println!(\"  \u2022 OpenAPI/Swagger documentation at /docs\");\n    println!(\"  \u2022 Default admin API key: {}\", admin_key.key_id);\n    \n    println!(\"\\n\ud83d\udcc8 API Endpoints Available:\");\n    println!(\"  POST /api/v1/metrics - Submit metrics\");\n    println!(\"  GET  /api/v1/metrics - Query metrics\");\n    println!(\"  GET  /api/v1/insights - Get ML insights\");\n    println!(\"  POST /api/v1/alerts/rules - Create alert rules\");\n    println!(\"  GET  /api/v1/alerts/rules - List alert rules\");\n    println!(\"  POST /api/v1/admin/api-keys - Create API keys\");\n    \n    println!(\"\\n\ud83d\ude80 Ready to serve analytics API requests!\");\n    \n    // Start the server (this would run indefinitely in production)\n    // server.start().await?;\n    \n    Ok(())\n}\n"